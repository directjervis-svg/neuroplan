import { z } from "zod";
import { router, protectedProcedure } from "./_core/trpc";
import { getDb } from "./db";

const db = await getDb();
import { sessionNotes, projects } from "../drizzle/schema";
import { eq, and, desc } from "drizzle-orm";

export const sessionNotesRouter = router({
  // Obter última nota de sessão (para "Onde Parei")
  getLastNote: protectedProcedure.query(async ({ ctx }) => {
    const userId = ctx.user.id;
    
    const lastNote = await db.query.sessionNotes.findFirst({
      where: eq(sessionNotes.userId, userId),
      orderBy: [desc(sessionNotes.createdAt)],
    });

    if (!lastNote) {
      return null;
    }

    // Buscar nome do projeto se existir
    let projectName = null;
    if (lastNote.projectId) {
      const project = await db.query.projects.findFirst({
        where: eq(projects.id, lastNote.projectId),
      });
      projectName = project?.title;
    }

    return {
      ...lastNote,
      projectName,
    };
  }),

  // Salvar nota de sessão (manual ou automática)
  saveNote: protectedProcedure
    .input(z.object({
      note: z.string().max(500),
      projectId: z.number().optional(),
      isAutoGenerated: z.boolean().default(false),
      taskContext: z.object({
        lastTaskId: z.number().optional(),
        lastTaskTitle: z.string().optional(),
        progress: z.number().optional(),
      }).optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.user.id;
      const today = new Date().toISOString().split('T')[0];

      // Verificar se já existe nota para hoje
      const existingNote = await db.query.sessionNotes.findFirst({
        where: and(
          eq(sessionNotes.userId, userId),
          eq(sessionNotes.sessionDate, new Date(today))
        ),
      });

      if (existingNote) {
        // Atualizar nota existente
        await db.update(sessionNotes)
          .set({
            note: input.note,
            projectId: input.projectId,
            taskContext: input.taskContext,
            isAutoGenerated: input.isAutoGenerated,
          })
          .where(eq(sessionNotes.id, existingNote.id));

        return { success: true, noteId: existingNote.id };
      }

      // Criar nova nota
      const [newNote] = await db.insert(sessionNotes).values({
        userId,
        note: input.note,
        projectId: input.projectId,
        isAutoGenerated: input.isAutoGenerated,
        taskContext: input.taskContext,
        sessionDate: new Date(today),
      });

      return { success: true, noteId: newNote.insertId };
    }),

  // Gerar resumo automático usando IA
  generateAutoSummary: protectedProcedure
    .input(z.object({
      projectId: z.number(),
    }))
    .mutation(async ({ ctx, input }) => {
      const userId = ctx.user.id;

      // Buscar tarefas recentes do projeto
      const recentTasks = await db.query.tasks.findMany({
        where: and(
          eq(tasks.projectId, input.projectId),
          eq(tasks.userId, userId)
        ),
        orderBy: [desc(tasks.updatedAt)],
        limit: 5,
      });

      // Buscar projeto
      const project = await db.query.projects.findFirst({
        where: and(
          eq(projects.id, input.projectId),
          eq(projects.userId, userId)
        ),
      });

      if (!project) {
        throw new Error("Projeto não encontrado");
      }

      // Gerar resumo com IA (simulado por enquanto)
      const completedTasks = recentTasks.filter(t => t.completedAt);
      const pendingTasks = recentTasks.filter(t => !t.completedAt);

      let summary = `Você estava trabalhando em "${project.title}". `;

      if (completedTasks.length > 0) {
        summary += `Você completou ${completedTasks.length} tarefa(s) recentemente. `;
      }

      if (pendingTasks.length > 0) {
        const nextTask = pendingTasks[0];
        summary += `Próximo passo: ${nextTask.title}.`;
      } else {
        summary += `Todas as tarefas recentes foram concluídas!`;
      }

      // Salvar resumo automático
      const today = new Date().toISOString().split('T')[0];
      await db.insert(sessionNotes).values({
        userId,
        projectId: input.projectId,
        note: summary,
        isAutoGenerated: true,
        taskContext: pendingTasks[0] ? {
          lastTaskId: pendingTasks[0].id,
          lastTaskTitle: pendingTasks[0].title,
          progress: Math.round((completedTasks.length / recentTasks.length) * 100),
        } : undefined,
        sessionDate: new Date(today),
      });

      return { summary };
    }),
});
